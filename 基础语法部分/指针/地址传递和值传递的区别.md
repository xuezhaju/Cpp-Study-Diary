# C++ 中地址传递与值传递的区别与应用

## 1. 核心区别

### 值传递 (Pass by Value)
```cpp
void modifyValue(int x) {
    x = 100;  // 修改的是副本，不影响原始数据
}

int main() {
    int a = 10;
    modifyValue(a);
    cout << a;  // 输出：10
}
```

### 地址传递 (Pass by Address/Reference)
```cpp
// 指针传递 (地址传递的一种)
void modifyByPointer(int* ptr) {
    *ptr = 100;  // 修改原始数据
}

// 引用传递 (地址传递的语法糖)
void modifyByReference(int& ref) {
    ref = 100;  // 修改原始数据
}

int main() {
    int a = 10;
    modifyByPointer(&a);  // 传递地址
    cout << a;  // 输出：100
    
    int b = 20;
    modifyByReference(b);  // 传递引用
    cout << b;  // 输出：100
}
```

## 2. 详细对比

| 特性 | 值传递 | 地址传递（指针） | 地址传递（引用） |
|------|--------|------------------|------------------|
| 传递内容 | 数据的副本 | 内存地址 | 引用（底层是地址） |
| 内存开销 | 复制整个对象 | 复制指针（通常4/8字节） | 复制引用（通常4/8字节） |
| 原始数据 | 不受影响 | 可能被修改 | 可能被修改 |
| 空值安全性 | 总是有效 | 可能为nullptr | 不能为null |
| 语法简洁性 | 简单 | 需要*和&操作符 | 简洁，像值传递 |
| const修饰 | 可以 | 可以有多层const | 可以 |

## 3. 实际应用场景

### 适合值传递的场景：
```cpp
// 1. 小型内置类型
void printValue(int x) { ... }

// 2. 不需要修改原始数据
double calculateDistance(Point p1, Point p2) {
    return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));
}

// 3. 需要原始数据的副本
void processData(vector<int> data) {
    sort(data.begin(), data.end());  // 不改变原始数据
}
```

### 适合地址传递的场景：
```cpp
// 1. 大型对象（避免复制开销）
void processLargeObject(const LargeObject& obj) {  // 引用传递
    // 只读访问大型对象
}

// 2. 需要修改参数
void swap(int& a, int& b) {  // 引用传递
    int temp = a;
    a = b;
    b = temp;
}

// 3. 输出参数
bool parseString(const string& input, int& result) {  // 引用传递
    // result 作为输出参数
}

// 4. 动态内存管理
void createArray(int** arr, int size) {  // 指针传递
    *arr = new int[size];
}

// 5. 可选参数（指针可传nullptr）
void configureDevice(DeviceConfig* optionalConfig = nullptr) {
    if (optionalConfig) {
        // 使用配置
    }
}
```

## 4. 现代C++最佳实践

```cpp
// 1. 优先使用const引用传递大型对象
void process(const std::vector<int>& data) {
    // 只读访问，无复制开销
}

// 2. 需要修改时使用非const引用
void normalizeVector(std::vector<int>& data) {
    for (auto& item : data) item /= 2;
}

// 3. 小型内置类型使用值传递
void increment(int x) { return x + 1; }

// 4. 使用智能指针代替原始指针
void processObject(std::shared_ptr<MyClass> obj) {
    // 自动内存管理
}

// 5. 移动语义优化（C++11+）
void storeData(std::vector<int>&& data) {  // 右值引用
    m_data = std::move(data);  // 移动而非复制
}

// 6. 使用std::optional作为可选返回值
std::optional<int> findValue(const std::vector<int>& vec, int target) {
    auto it = std::find(vec.begin(), vec.end(), target);
    if (it != vec.end()) return *it;
    return std::nullopt;  // 比返回指针更安全
}
```

## 5. 性能考虑

```cpp
struct LargeData {
    int array[1000];
    // 很多数据...
};

// 糟糕：复制开销大
void badFunction(LargeData data) { ... }

// 良好：无复制开销
void goodFunction(const LargeData& data) { ... }

// 特例：小型结构体（<= 16字节）有时值传递更快
struct Point3D { float x, y, z; };  // 12字节
void processPoint(Point3D p) { ... }  // 可能比引用传递更快
```

## 6. 选择指南

1. **默认选择const引用**：对于非内置类型的输入参数
2. **使用值传递**：对于内置类型和小型结构体
3. **使用非const引用**：需要修改参数时
4. **使用指针**：参数可选时（可传nullptr）
5. **避免输出参数**：优先使用返回值（C++17支持多返回值）

## 7. 总结

- **值传递**：安全但可能有性能开销，适合小数据
- **引用传递**：高效且安全，是现代C++的首选
- **指针传递**：灵活但需要空值检查，用于可选参数或C接口

在实际开发中，应根据数据类型大小、是否需要修改、是否为可选参数等因素综合考虑。现代C++中，引用通常比指针更受欢迎，因为它更安全、语法更简洁。