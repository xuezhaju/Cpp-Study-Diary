# C++ 结构体与指针完全指南

## 1. 结构体指针基础

### 1.1 定义结构体指针
```cpp
struct Student {
    string name;
    int age;
    float score;
};

int main() {
    Student stu = {"张三", 18, 90.5};
    
    // 定义结构体指针
    Student* pStu = &stu;
    
    cout << "学生信息：" << endl;
    cout << "姓名：" << pStu->name << endl;     // 使用->访问成员
    cout << "年龄：" << (*pStu).age << endl;   // 使用*和.访问成员
    cout << "成绩：" << pStu->score << endl;    // -> 更常用
    
    return 0;
}
```

### 1.2 两种访问方式的区别
```cpp
Student stu = {"李四", 20, 88.0};
Student* ptr = &stu;

// 方式1：指针->成员（推荐）
ptr->name = "王五";    // 简洁明了

// 方式2：(*指针).成员
(*ptr).age = 21;       // 需要括号，否则会出错

// 错误示范：
// *ptr.age = 22;      // 错误！因为.优先级高于*
```

## 2. 结构体指针的内存模型

```cpp
#include <iostream>
using namespace std;

struct Point {
    int x;
    int y;
};

int main() {
    Point p = {10, 20};
    Point* ptr = &p;
    
    cout << "内存布局分析：" << endl;
    cout << "变量p的地址: " << &p << endl;
    cout << "指针ptr的值: " << ptr << endl;      // 与&p相同
    cout << "指针ptr的地址: " << &ptr << endl;   // ptr自己的地址
    
    cout << "\n成员地址：" << endl;
    cout << "p.x的地址: " << &p.x << endl;       // &p + 0
    cout << "p.y的地址: " << &p.y << endl;       // &p + 4
    
    cout << "\n通过指针访问：" << endl;
    cout << "ptr->x: " << ptr->x << endl;        // 10
    cout << "ptr->y: " << ptr->y << endl;        // 20
    
    return 0;
}
```

## 3. 动态分配结构体

### 3.1 单个结构体的动态分配
```cpp
struct Student {
    string name;
    int age;
};

int main() {
    // 动态分配单个结构体
    Student* pStu = new Student;
    
    // 赋值
    pStu->name = "张三";
    pStu->age = 19;
    
    // 使用
    cout << pStu->name << " " << pStu->age << endl;
    
    // 释放内存
    delete pStu;
    pStu = nullptr;  // 防止野指针
    
    return 0;
}
```

### 3.2 结构体数组的动态分配
```cpp
struct Employee {
    int id;
    string name;
    double salary;
};

int main() {
    int n = 3;
    
    // 动态分配结构体数组
    Employee* employees = new Employee[n];
    
    // 初始化
    for (int i = 0; i < n; i++) {
        employees[i].id = i + 1;
        employees[i].name = "员工" + to_string(i + 1);
        employees[i].salary = 5000 + i * 1000;
    }
    
    // 使用指针访问
    for (int i = 0; i < n; i++) {
        cout << (employees + i)->id << " "  // 指针运算
             << employees[i].name << " "     // 数组下标
             << employees[i].salary << endl;
    }
    
    // 释放内存
    delete[] employees;
    employees = nullptr;
    
    return 0;
}
```

## 4. 结构体指针作为函数参数

### 4.1 传入指针修改结构体
```cpp
struct Rectangle {
    double width;
    double height;
};

// 修改结构体内容
void resize(Rectangle* rect, double factor) {
    if (rect != nullptr) {
        rect->width *= factor;
        rect->height *= factor;
    }
}

// 只读访问（使用const保护）
void printRect(const Rectangle* rect) {
    if (rect != nullptr) {
        cout << "宽度: " << rect->width 
             << ", 高度: " << rect->height << endl;
    }
}

double calculateArea(const Rectangle* rect) {
    if (rect == nullptr) return 0.0;
    return rect->width * rect->height;
}

int main() {
    Rectangle r = {10.0, 5.0};
    
    printRect(&r);                    // 打印原尺寸
    cout << "面积: " << calculateArea(&r) << endl;
    
    resize(&r, 1.5);                  // 放大1.5倍
    printRect(&r);
    cout << "新面积: " << calculateArea(&r) << endl;
    
    return 0;
}
```

### 4.2 返回结构体指针
```cpp
struct Product {
    int id;
    string name;
    double price;
};

// 在堆上创建并返回结构体指针
Product* createProduct(int id, string name, double price) {
    Product* p = new Product;
    p->id = id;
    p->name = name;
    p->price = price;
    return p;
}

// 查找函数返回指针
Product* findProduct(Product* products, int count, int targetId) {
    for (int i = 0; i < count; i++) {
        if (products[i].id == targetId) {
            return &products[i];  // 返回地址
        }
    }
    return nullptr;
}

int main() {
    // 动态创建产品
    Product* p1 = createProduct(1001, "手机", 2999.0);
    cout << p1->name << ": " << p1->price << endl;
    delete p1;
    
    // 在数组中查找
    Product products[3] = {
        {1001, "笔记本", 5999.0},
        {1002, "平板", 3299.0},
        {1003, "耳机", 499.0}
    };
    
    Product* found = findProduct(products, 3, 1002);
    if (found != nullptr) {
        cout << "找到: " << found->name << endl;
        found->price = 2999.0;  // 打折
    }
    
    return 0;
}
```

## 5. 结构体指针数组

```cpp
struct Book {
    string title;
    string author;
    double price;
};

int main() {
    // 创建指针数组（每个元素都是指针）
    Book* library[3];
    
    // 为每个指针分配内存
    for (int i = 0; i < 3; i++) {
        library[i] = new Book;
    }
    
    // 初始化
    library[0]->title = "C++ Primer";
    library[0]->author = "Stanley";
    library[0]->price = 128.0;
    
    library[1]->title = "Effective C++";
    library[1]->author = "Scott";
    library[1]->price = 89.0;
    
    library[2]->title = "设计模式";
    library[2]->author = "GoF";
    library[2]->price = 99.0;
    
    // 遍历指针数组
    for (int i = 0; i < 3; i++) {
        cout << library[i]->title << " - "
             << library[i]->author << " - "
             << library[i]->price << endl;
    }
    
    // 释放内存
    for (int i = 0; i < 3; i++) {
        delete library[i];
        library[i] = nullptr;
    }
    
    return 0;
}
```

## 6. 指向结构体数组的指针

```cpp
struct Student {
    int id;
    string name;
    int score;
};

int main() {
    Student students[5] = {
        {101, "张三", 85},
        {102, "李四", 92},
        {103, "王五", 78},
        {104, "赵六", 95},
        {105, "钱七", 88}
    };
    
    // 指向数组的指针
    Student* ptr = students;  // 等价于 &students[0]
    
    // 使用指针遍历数组
    for (int i = 0; i < 5; i++) {
        cout << "学生" << i+1 << ": "
             << ptr->name << " " 
             << ptr->score << endl;
        ptr++;  // 移动到下一个结构体
    }
    
    // 重置指针
    ptr = students;
    
    // 另一种遍历方式
    for (int i = 0; i < 5; i++) {
        cout << (ptr + i)->id << " "  // 指针运算
             << students[i].name << endl;  // 数组下标
    }
    
    // 指针运算示例
    Student* middle = students + 2;  // 指向第三个元素
    cout << "中间学生: " << middle->name << endl;
    
    // 指针比较
    Student* end = students + 5;  // 数组末尾之后
    for (Student* p = students; p < end; p++) {
        if (p->score > 90) {
            cout << "优秀学生: " << p->name << endl;
        }
    }
    
    return 0;
}
```

## 7. 结构体中的指针成员

```cpp
#include <cstring>  // for strcpy

struct Person {
    char* name;      // 指针成员
    int age;
    
    // 构造函数
    Person(const char* n, int a) {
        name = new char[strlen(n) + 1];
        strcpy(name, n);
        age = a;
    }
    
    // 析构函数（必须！）
    ~Person() {
        delete[] name;
        name = nullptr;
    }
    
    // 拷贝构造函数（防止浅拷贝问题）
    Person(const Person& other) {
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
        age = other.age;
    }
    
    // 显示信息
    void display() {
        cout << name << ", " << age << "岁" << endl;
    }
};

int main() {
    // 创建对象
    Person p1("张三", 25);
    p1.display();
    
    // 拷贝对象（深拷贝）
    Person p2 = p1;
    p2.display();
    
    // 修改p2的名字
    delete[] p2.name;
    p2.name = new char[20];
    strcpy(p2.name, "李四");
    p2.age = 30;
    
    cout << "修改后：" << endl;
    p1.display();  // 还是"张三"
    p2.display();  // 变为"李四"
    
    return 0;
}
```

## 8. 结构体指针与链表

```cpp
// 链表节点结构
struct ListNode {
    int data;
    ListNode* next;  // 指向下一个节点的指针
    
    ListNode(int val) : data(val), next(nullptr) {}
};

// 链表操作函数
void addNode(ListNode*& head, int value) {
    ListNode* newNode = new ListNode(value);
    
    if (head == nullptr) {
        head = newNode;
    } else {
        ListNode* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
    }
}

void printList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "NULL" << endl;
}

void deleteList(ListNode*& head) {
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
}

int main() {
    ListNode* head = nullptr;
    
    // 添加节点
    addNode(head, 10);
    addNode(head, 20);
    addNode(head, 30);
    
    // 打印链表
    printList(head);
    
    // 遍历链表
    ListNode* current = head;
    while (current != nullptr) {
        cout << "当前节点值: " << current->data << endl;
        current = current->next;  // 移动到下一个节点
    }
    
    // 释放内存
    deleteList(head);
    
    return 0;
}
```

## 9. 结构体指针与多级指针

```cpp
struct Student {
    string name;
    int score;
};

// 修改指针的指向
void changePointer(Student** ppStudent) {
    static Student newStu = {"新学生", 100};
    *ppStudent = &newStu;  // 修改指针指向
}

// 修改指针指向的内容
void changeContent(Student* pStudent) {
    pStudent->score = 95;  // 修改内容
}

int main() {
    Student stu1 = {"张三", 85};
    Student* pStu = &stu1;
    
    cout << "修改前: " << pStu->name << " " << pStu->score << endl;
    
    // 修改内容
    changeContent(pStu);
    cout << "修改内容后: " << pStu->name << " " << pStu->score << endl;
    
    // 修改指针指向
    changePointer(&pStu);  // 传递指针的地址
    cout << "修改指针后: " << pStu->name << " " << pStu->score << endl;
    
    // 三级指针示例
    Student stu2 = {"李四", 90};
    Student* p1 = &stu2;
    Student** p2 = &p1;
    Student*** p3 = &p2;
    
    cout << "\n三级指针访问:" << endl;
    cout << "***p3: " << (**p3)->name << endl;
    cout << "(*p3)->name: " << (*p2)->name << endl;
    
    return 0;
}
```

## 10. 常见错误与注意事项

```cpp
struct Data {
    int value;
    string name;
};

void commonMistakes() {
    // 1. 野指针
    Data* p1;           // ❌ 未初始化
    // p1->value = 10;  // 危险！
    
    // 2. 空指针解引用
    Data* p2 = nullptr;
    // p2->value = 20;  // ❌ 运行时错误
    
    // 3. 内存泄漏
    Data* p3 = new Data;
    p3->value = 30;
    // 忘记 delete p3;  // ❌ 内存泄漏
    
    // 4. 重复释放
    Data* p4 = new Data;
    delete p4;
    // delete p4;       // ❌ 重复释放，程序崩溃
    
    // 5. 访问已释放的内存
    Data* p5 = new Data;
    delete p5;
    // p5->value = 50;  // ❌ 访问已释放内存
    
    // 6. 数组删除错误
    Data* arr = new Data[5];
    // delete arr;      // ❌ 应该用 delete[] arr;
    delete[] arr;       // ✅ 正确
    
    // 7. 结构体指针的类型安全
    struct A { int x; };
    struct B { int y; };
    
    A a;
    B* pB = (B*)&a;     // ❌ 危险的类型转换
    // pB->y = 100;     // 可能破坏内存
}

// 正确做法
void correctApproach() {
    // 1. 总是初始化指针
    Data* p1 = nullptr;  // ✅
    
    // 2. 使用前检查空指针
    if (p1 != nullptr) {
        p1->value = 10;  // 安全
    }
    
    // 3. 动态分配后记得释放
    Data* p2 = new Data;
    // 使用p2...
    delete p2;           // ✅
    p2 = nullptr;        // ✅ 防止野指针
    
    // 4. 使用智能指针（C++11+）
    #include <memory>
    auto p3 = std::make_unique<Data>();  // 自动管理内存
    p3->value = 30;                      // 安全使用
    // 不需要手动delete
}
```

## 11. 实战案例：学生管理系统

```cpp
#include <iostream>
#include <string>
#include <iomanip>
using namespace std;

struct Student {
    int id;
    string name;
    double score;
    Student* next;
};

class StudentManager {
private:
    Student* head;
    int count;
    
public:
    StudentManager() : head(nullptr), count(0) {}
    
    ~StudentManager() {
        clearAll();
    }
    
    // 添加学生
    void addStudent(int id, string name, double score) {
        Student* newStu = new Student{id, name, score, nullptr};
        
        if (head == nullptr) {
            head = newStu;
        } else {
            Student* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newStu;
        }
        count++;
        cout << "添加成功！" << endl;
    }
    
    // 查找学生
    Student* findStudent(int id) {
        Student* current = head;
        while (current != nullptr) {
            if (current->id == id) {
                return current;
            }
            current = current->next;
        }
        return nullptr;
    }
    
    // 删除学生
    bool deleteStudent(int id) {
        if (head == nullptr) return false;
        
        // 如果是头节点
        if (head->id == id) {
            Student* temp = head;
            head = head->next;
            delete temp;
            count--;
            return true;
        }
        
        // 查找并删除
        Student* current = head;
        while (current->next != nullptr) {
            if (current->next->id == id) {
                Student* temp = current->next;
                current->next = temp->next;
                delete temp;
                count--;
                return true;
            }
            current = current->next;
        }
        return false;
    }
    
    // 显示所有学生
    void displayAll() {
        if (head == nullptr) {
            cout << "没有学生记录！" << endl;
            return;
        }
        
        cout << "\n========== 学生列表 ==========" << endl;
        cout << left << setw(8) << "学号" 
             << setw(15) << "姓名"
             << setw(8) << "成绩" << endl;
        cout << "-------------------------------" << endl;
        
        Student* current = head;
        while (current != nullptr) {
            cout << left << setw(8) << current->id
                 << setw(15) << current->name
                 << setw(8) << fixed << setprecision(1) << current->score << endl;
            current = current->next;
        }
        cout << "共 " << count << " 名学生" << endl;
    }
    
    // 清空所有
    void clearAll() {
        while (head != nullptr) {
            Student* temp = head;
            head = head->next;
            delete temp;
        }
        count = 0;
    }
    
    // 统计平均分
    double getAverage() {
        if (count == 0) return 0.0;
        
        double total = 0.0;
        Student* current = head;
        while (current != nullptr) {
            total += current->score;
            current = current->next;
        }
        return total / count;
    }
};

int main() {
    StudentManager manager;
    
    // 添加学生
    manager.addStudent(1001, "张三", 85.5);
    manager.addStudent(1002, "李四", 92.0);
    manager.addStudent(1003, "王五", 78.5);
    
    // 显示所有
    manager.displayAll();
    
    // 查找学生
    Student* found = manager.findStudent(1002);
    if (found != nullptr) {
        cout << "\n找到学生: " << found->name 
             << ", 成绩: " << found->score << endl;
    }
    
    // 修改学生成绩
    if (found != nullptr) {
        found->score = 95.0;
        cout << "修改后成绩: " << found->score << endl;
    }
    
    // 删除学生
    if (manager.deleteStudent(1001)) {
        cout << "\n删除学号1001成功！" << endl;
    }
    
    // 再次显示
    manager.displayAll();
    
    // 计算平均分
    cout << "\n全班平均分: " << manager.getAverage() << endl;
    
    return 0;
}
```

## 总结

### 关键点回顾：

1. **访问方式**：
   - `ptr->member`（推荐）
   - `(*ptr).member`

2. **内存管理**：
   - `new` / `delete` 单个对象
   - `new[]` / `delete[]` 数组
   - 避免内存泄漏和野指针

3. **函数参数**：
   - 传递指针可修改原始数据
   - 使用`const`保护只读数据
   - 可返回指针（注意生命周期）

4. **常见结构**：
   - 链表节点
   - 指针数组
   - 动态结构体数组

5. **最佳实践**：
   - 总是初始化指针
   - 使用前检查空指针
   - 及时释放内存
   - 考虑使用智能指针

### 应用场景：
- 动态数据结构（链表、树）
- 大型数据的高效传递
- 需要在函数间共享和修改数据
- 管理动态分配的对象数组

掌握结构体指针是理解C++底层内存管理和构建复杂数据结构的基础！